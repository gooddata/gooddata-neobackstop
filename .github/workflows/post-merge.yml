name: Push ~ post merge phase

on:
  push:
    branches: ["master"]

jobs:
  check-pr-labels:
    name: Check PR Labels
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    permissions:
      contents: read
      pull-requests: read
    outputs:
      skip_publish: ${{ steps.check_labels.outputs.skip_publish }}
    steps:
      - name: Get PR number and check labels
        id: check_labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Find PR associated with this commit
            const commit_sha = context.sha;
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commit_sha
            });
            
            let skipPublish = false;
            
            if (prs.length > 0) {
              const pr = prs[0];
              console.log(`Found PR #${pr.number} associated with commit ${commit_sha}`);
              
              // Check if PR has "skip publish" label
              const hasSkipPublishLabel = pr.labels.some(label => label.name === 'skip publish');
              
              if (hasSkipPublishLabel) {
                console.log('PR has "skip publish" label - publishing will be skipped');
                skipPublish = true;
              } else {
                console.log('PR does not have "skip publish" label - proceeding with publish');
              }
            } else {
              console.log('No PR found for this commit - proceeding with publish');
            }
            
            core.setOutput('skip_publish', skipPublish);

  check-dependencies-changed:
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    permissions:
      contents: read
    outputs:
      changed: ${{ steps.filter.outputs.changed }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            changed:
              - 'go.sum'

  fossa-scan:
    permissions:
      id-token: write
      contents: read
      pull-requests: read
    name: fossa-scan
    needs: check-dependencies-changed
    if: ${{ needs.check-dependencies-changed.outputs.changed == 'true' }}
    uses: ./.github/workflows/rw-fossa.yml
    with:
      branch: 'master'
    secrets: inherit

  docker-build-and-publish:
    name: Build and publish Docker image
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    needs: check-pr-labels
    if: ${{ needs.check-pr-labels.outputs.skip_publish != 'true' }}
    environment: public-release
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Read VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version to be published: ${VERSION}"

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: gooddatatiger
          password: ${{ secrets.DOCKERHUB_WRITE_TOKEN }}

      - name: Build and push Docker image with version tag
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            gooddata/gooddata-neobackstop:${{ steps.version.outputs.VERSION }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Install crane
        uses: imjasonh/setup-crane@v0.3

      - name: Tag image as latest
        run: |
          crane tag gooddata/gooddata-neobackstop:${{ steps.version.outputs.VERSION }} latest

      - name: Build summary
        run: |
          echo "### Docker Image Published Successfully ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** gooddata/gooddata-neobackstop" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.version.outputs.VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:** linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  create-git-tag:
    name: Create and push Git tag
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    needs: check-pr-labels
    if: ${{ needs.check-pr-labels.outputs.skip_publish != 'true' }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Git tag to be created: v${VERSION}"

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Create and push Git tag
        run: |
          TAG_NAME="v${{ steps.version.outputs.VERSION }}"

          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists. Skipping tag creation."
            echo "### Git Tag Already Exists ‚ö†Ô∏è" >> $GITHUB_STEP_SUMMARY
            echo "Tag \`$TAG_NAME\` already exists for this version." >> $GITHUB_STEP_SUMMARY
          else
            echo "Creating tag $TAG_NAME for commit ${{ github.sha }}"
            git tag -a "$TAG_NAME" -m "Release version ${{ steps.version.outputs.VERSION }}"
            git push origin "$TAG_NAME"
            echo "Successfully created and pushed tag: $TAG_NAME"

            echo "### Git Tag Created Successfully ‚úÖ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Tag:** \`$TAG_NAME\`" >> $GITHUB_STEP_SUMMARY
            echo "**Version:** ${{ steps.version.outputs.VERSION }}" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          fi

  extract-changelog:
    name: Extract and display changelog entry
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    permissions:
      contents: read
    outputs:
      changelog_text: ${{ steps.output.outputs.changelog_text }}
      changelog_json: ${{ steps.output.outputs.changelog_json }}
      version: ${{ steps.version.outputs.VERSION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Extracting changelog for version: ${VERSION}"

      - name: Extract changelog entry for current version
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          echo "Extracting changelog entry for version $VERSION..."

          # Check if the version exists in the changelog
          if ! grep -q "## \[$VERSION\]" CHANGELOG.md; then
            echo "‚ö†Ô∏è Warning: CHANGELOG.md does not contain an entry for version $VERSION" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Extract the section for this version using awk
          # This gets everything from the version header to the next version header or end of file
          awk "/## \[$VERSION\]/,/## \[/" CHANGELOG.md | head -n -1 > /tmp/version_section.txt

          # If the above didn't capture anything (last version in file), try without the ending pattern
          if [ ! -s /tmp/version_section.txt ]; then
            awk "/## \[$VERSION\]/,EOF" CHANGELOG.md > /tmp/version_section.txt
          fi

          # Save the changelog content to a file for the summary
          cat /tmp/version_section.txt > /tmp/changelog_content.txt

          # Output the raw content for debugging
          echo "Changelog content extracted:"
          cat /tmp/changelog_content.txt

      - name: Create changelog summary
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"

          echo "## üìã Release Notes for v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f /tmp/changelog_content.txt ] && [ -s /tmp/changelog_content.txt ]; then
            # Process and format the changelog content for the summary
            while IFS= read -r line; do
              # Skip empty lines at the beginning
              if [[ -z "$line" ]] && [[ ! "$started" ]]; then
                continue
              fi
              started=true

              # Format headers and content
              if [[ "$line" =~ ^##[[:space:]]\[.*\] ]]; then
                # Version header - make it bold
                echo "**${line}**" >> $GITHUB_STEP_SUMMARY
              elif [[ "$line" =~ ^###[[:space:]] ]]; then
                # Section headers (Added, Changed, etc.) - keep as is
                echo "$line" >> $GITHUB_STEP_SUMMARY
              else
                # Regular content - preserve formatting
                echo "$line" >> $GITHUB_STEP_SUMMARY
              fi
            done < /tmp/changelog_content.txt
          else
            echo "‚ö†Ô∏è No changelog entry found for version ${VERSION}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Consider adding a changelog entry in the following format:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "## [${VERSION}] - $(date +%Y-%m-%d)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Added" >> $GITHUB_STEP_SUMMARY
            echo "- New features" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Changed" >> $GITHUB_STEP_SUMMARY
            echo "- Changes in existing functionality" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Fixed" >> $GITHUB_STEP_SUMMARY
            echo "- Bug fixes" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Output changelog for other jobs
        id: output
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"

          if [ -f /tmp/changelog_content.txt ] && [ -s /tmp/changelog_content.txt ]; then
            # Read the changelog content
            CHANGELOG_TEXT=$(cat /tmp/changelog_content.txt)

            # Create a JSON-safe version by escaping special characters
            CHANGELOG_JSON=$(cat /tmp/changelog_content.txt | jq -Rs .)

            # For multiline output in GitHub Actions, we use EOF delimiter
            echo "changelog_text<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGELOG_TEXT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            # Output JSON version
            echo "changelog_json=${CHANGELOG_JSON}" >> $GITHUB_OUTPUT

            echo "Changelog content has been set as output"
          else
            # Set empty values if no changelog found
            echo "changelog_text=No changelog entry found for version ${VERSION}" >> $GITHUB_OUTPUT
            echo "changelog_json=\"No changelog entry found for version ${VERSION}\"" >> $GITHUB_OUTPUT
            echo "No changelog content to output"
          fi

  create-github-release:
    name: Create GitHub Release
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    needs: [check-pr-labels, docker-build-and-publish, create-git-tag, extract-changelog]
    if: ${{ needs.check-pr-labels.outputs.skip_publish != 'true' }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Creating GitHub release for version: ${VERSION}"

      - name: Create Release Body
        id: release_body
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          CHANGELOG="${{ needs.extract-changelog.outputs.changelog_text }}"

          # Create the release body with Docker information and changelog
          cat << EOF > release_body.md
          ## Docker Image

          The Docker image for this release has been published to DockerHub:

          **Repository:** \`gooddata/gooddata-neobackstop\`

          **Tags:**
          - \`gooddata/gooddata-neobackstop:${VERSION}\`
          - \`gooddata/gooddata-neobackstop:latest\`

          ### Pull Commands

          \`\`\`bash
          # Pull specific version
          docker pull gooddata/gooddata-neobackstop:${VERSION}

          # Pull latest
          docker pull gooddata/gooddata-neobackstop:latest
          \`\`\`

          ### Run Command

          \`\`\`bash
          docker run --rm gooddata/gooddata-neobackstop:${VERSION} [command]
          \`\`\`

          ## Changelog

          ${CHANGELOG}

          ## Build Information

          - **Commit:** ${{ github.sha }}
          - **Build Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF

          echo "Release body created"

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: v${{ steps.version.outputs.VERSION }}
          name: Release v${{ steps.version.outputs.VERSION }}
          bodyFile: release_body.md
          draft: false
          prerelease: false
          makeLatest: true
          generateReleaseNotes: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"

          echo "### üéâ GitHub Release Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Docker Image:** \`gooddata/gooddata-neobackstop:${VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v${VERSION})" >> $GITHUB_STEP_SUMMARY

  trigger-go-proxy:
    name: Trigger Go Proxy Update
    runs-on:
      group: infra1-runners-arc
      labels: runners-small
    needs: [check-pr-labels, create-git-tag]
    if: ${{ needs.check-pr-labels.outputs.skip_publish != 'true' }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Will trigger Go proxy for version: v${VERSION}"

      - name: Trigger Go proxy to fetch new version
        id: trigger_proxy
        run: |
          VERSION="v${{ steps.version.outputs.VERSION }}"
          URL="https://proxy.golang.org/github.com/gooddata/gooddata-neobackstop/@v/${VERSION}.info"

          echo "Triggering Go proxy to fetch version ${VERSION}..."
          echo "Request URL: ${URL}"
          echo ""

          # Make the GET request and capture response
          HTTP_STATUS=$(curl -s -o /tmp/response.txt -w "%{http_code}" "${URL}")

          echo "HTTP Status Code: ${HTTP_STATUS}"
          echo "Response content:"
          cat /tmp/response.txt
          echo ""

          # Check if status is 200
          if [ "${HTTP_STATUS}" -eq 200 ]; then
            echo "‚úÖ Success: Go proxy successfully fetched version ${VERSION}"

            # Parse the JSON response if it's valid
            if command -v jq >/dev/null 2>&1; then
              if jq -e . /tmp/response.txt >/dev/null 2>&1; then
                echo ""
                echo "Version info from proxy:"
                jq . /tmp/response.txt
              fi
            fi

            echo "### Go Proxy Update Triggered Successfully ‚úÖ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Module:** \`github.com/gooddata/gooddata-neobackstop\`" >> $GITHUB_STEP_SUMMARY
            echo "**Version:** \`${VERSION}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The module is now available at:" >> $GITHUB_STEP_SUMMARY
            echo "- [pkg.go.dev](https://pkg.go.dev/github.com/gooddata/gooddata-neobackstop@${VERSION})" >> $GITHUB_STEP_SUMMARY
            echo "- [Go Proxy](${URL})" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Error: Failed to trigger Go proxy update"
            echo "Expected HTTP status 200, got ${HTTP_STATUS}"

            echo "### Go Proxy Update Failed ‚ùå" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**HTTP Status:** ${HTTP_STATUS}" >> $GITHUB_STEP_SUMMARY
            echo "**Version:** ${VERSION}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The Go proxy could not fetch the new version. This might happen if:" >> $GITHUB_STEP_SUMMARY
            echo "- The repository is private" >> $GITHUB_STEP_SUMMARY
            echo "- The git tag hasn't propagated yet" >> $GITHUB_STEP_SUMMARY
            echo "- There's an issue with the module path" >> $GITHUB_STEP_SUMMARY

            # Exit with failure
            exit 1
          fi

      - name: Verify module availability
        run: |
          VERSION="v${{ steps.version.outputs.VERSION }}"
          MODULE="github.com/gooddata/gooddata-neobackstop@${VERSION}"

          echo "Verifying module availability..."
          echo "Checking: ${MODULE}"

          # Additional verification using go list (if Go is available)
          if command -v go >/dev/null 2>&1; then
            echo ""
            echo "Attempting to verify with go list..."
            if go list -m "${MODULE}" 2>/dev/null; then
              echo "‚úÖ Module is available via go toolchain"
            else
              echo "‚ö†Ô∏è  Module not yet available via go toolchain (may take a few minutes to propagate)"
            fi
          fi